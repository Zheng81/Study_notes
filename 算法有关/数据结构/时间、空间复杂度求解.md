# 时间、空间复杂度求解

## 分析非递归算法的时间复杂度

## 分析递归算法的时间复杂度

> 分析递归算法推荐两种方法:
>
> 1. 迭代法
> 2. 公式法

### **1.迭代法**

**举例:**分析汉诺塔递归函数的时间复杂度。

```
void hano(char A, char B, char C, int n) {
	if(n > 0) {
		hano(A, C, B, n - 1);
		move(A, C);
		hano(B, A, C, n - 1);
	}
}
```

假设这个递归函数的运行时间时T(n)。

- if语句（一般取if块或else块之间最大的时间复杂度）中，比较和判断n的大小,CPU的执行时间为1个单位。

- 两次调用递归函数，每次都使问题的规模减少1个，得到两倍的T(n - 1)。打印输出的语句，CPU的执行时间也为1个单位。因此得出：T(n) = 1 + 2 * T(n - 1)  + 1。

  此处if语句和打印输出语句的执行时间与问题规模n无关，因此它们的算法时间复杂度可以记为O(1)，表达式变为：T(n) = 2 * T(n - 1) + O(1)。

- 用迭代法将T(n)进行展开。

  T(n - 1) = 2 * T(n - 2) + 1,以此类推，不断地代入到T(n)的表达式当中，得到如下关系:

  T(n) = 2 * (2 * T(n - 2) + 1) + 1 = 2 ^2 * T(n - 2) + (2 + 1)

  T(n) = 2 * (2 * (2 * T(n - 3) + 1) + 1) + 1 = 2^3 * T(n - 3) + (4 + 2 + 1)

  T(n) = 2 * (2 * (2 * (2 * T(n - 4) + 1) + 1) + 1) + 1 = 2^4 * T(n - 4) + (8 + 4 + 2 +1)

  ......

  T(n) = 2 ^k * T(n - k) + (2^k - 1)

  其中，1 + 2 + 4 + 8 + ...是一个等比数列，由求和公式得到2^k - 1。当K等于n的时候， 2^n * T(0) + (2^n - 1)，由于T(0)等于1，所以最终T(n) = 2 * 2^n - 1。

  

![](F:\笔记\算法有关\assets\时间复杂度.png)

![](F:\笔记\算法有关\assets\时间复杂度2.png)

![](F:\笔记\算法有关\assets\时间复杂度之公式法.png)