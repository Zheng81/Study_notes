# 使用线程池比手动创建线程好在哪里？

> 首先我们得知道我们为什么要使用线程池?

在没有线程池的时候，我们每发布了一个任务，那么就需要创建一个新的线程，但线程数过多的话，就会使得程序的开销大，因为在程序中创建线程和销毁线程消耗的资源比线程执行任务本身消耗的资源还要大。而且过多的线程会占用过多的内存，而且还会带来过多的上下文切换，导致系统的不稳定。而线程池就是用来解决这种问题。

> 线程池解决问题思路

针对上面的问题，线程池有两个解决思路。

首先，针对反复创建线程开销大的问题，线程池用一些固定的线程一直保持工作状态并反复执行任务

其次，针对过多线程占用太多内存资源的问题，解决思路更直接，线程池会根据需要创建线程，控制线程的总数量，避免占用过多内存资源。

> 如何使用线程池

线程池就好比一个池塘，池塘里的水是有限且可控的，比如我们选择线程数固定数量的线程池，假设线程池有5个线程,但此时的任务大于5个，线程池会让余下的任务进行排队，而不是无限制的扩张线程数量，保障资源不会被过度消耗。(就算你的任务再多，执行任务的最多也就只有这5个线程)

> 使用线程池的好处

1. 线程池可以解决线程生命周期的系统开销问题，同时还可以加快响应速度。因为线程池中的线程是可以复用的，我们只用少量的线程去执行大量的任务，这样就大大减小了线程生命周期的开销。而且线程通常不是等接到任务后再临时创建，而是已经创建好时刻准备执行任务，这样就消除了线程创建所带来的延迟，提升了响应速度，增强了用户体验。
2. 线程可以统筹内存和CPU的使用，避免资源使用不当，线程池会根据配置和任务数量灵活地控制线程数量，不够的时候就创建，太多的时候就回收，避免线程过多导致内存溢出，或线程太少导致CPU资源的浪费，达到一个完美的平衡。
3. 线程池可以统一管理资源。比如线程池可以统一管理任务队列和线程，可以统一开始或结束任务，比单个线程逐一处理任务要更方便，更易于管理，同时也有利于数据统计，比如我们可以很方便地统计出已经执行的任务的数量



## 线程池的各个参数的含义

线程池的参数

![](F:\笔记\java_Study\Multithreading\asstes\线程池的参数.png)

线程池中主要的参数有6个，而其中第3个参数由keepAliveTime + 时间单位组成。corePoolSize是核心线程数，也就是常驻线程池的线程数量，与它对应的是maxPoolSize,表示线程池最大线程数量，当我们的任务特别多而corePoolSize核心线程数无法满足需求时，就会向线程池中增加线程，以便应对任务突增的情况。

> 线程创建的时机

![](F:\笔记\java_Study\Multithreading\asstes\线程创建时机.png)

如图，当提交任务后，线程池首先会检查当前线程数，如果此时线程数小于核心线程数，比如最开始线程数量为0，则新建线程并执行任务，随着任务的不段增加，线程数会逐渐增加并达到核心线程数，此时如果仍有任务不断提交，就会被放入workQueue任务队列中，等待核心线程执行完当前任务后重新从workQueue中提取正在等待被执行的任务。

此时，假设我们的任务特别的多，已经达到了workQueue的容量上线，这是线程池就会启动后被力量，也就是maxPoolSize最大线程数，线程池会在corePoolSize核心线程数的基础上继续创建线程来执行任务，假设任务被不断提交，线程池会持续创建线程直到线程数达到maxPoolSize最大线程数，如果依然有任务被提交，这就超过了线程池的最大处理能力，这时线程池就会拒绝这些任务，我们可以看到实际上任务进来之后，线程池就会逐一判断corePoolSize、workQueue、maxPoolSize,如果依然不能满足需求，则会拒绝任务。

corePoolSize指的是:核心线程数，线程池初始化时线程默认为0，当有新的任务提交后，会创建新线程执行任务，如果不做特殊设置，此后线程数通常不会再小于corePoolSizze,因为他们是核心线程，即便未来可能没有可执行的任务也不会被销毁，随着任务量的增加，在任务队列满了之后，线程池会进一步创建新线程，最多可达到maxPoolSize来应对任务多的场景，如果未来线程有空闲，大于corePoolSize的线程会被合理回收，所有正常情况下，线程池中的线程数量会处在corePoolSize与maxPoolize的闭区间内。

其实corePoolSize和maxPoolSize其实可以相当于长工和临时工的关系，

![](F:\笔记\java_Study\Multithreading\asstes\长工和临时工.gif)

通过以上，我们可以总结出线程池的特点

1. 线程池希望保持较少的线程数，并且只有在负载变得很大时才增加线程。
2. 线程池只有在任务队列填满时才创建多于corePoolSize的线程，如果使用的是无界队列(例如LinkedBlockingQueue),那么由于队列不会满，所以线程数不会超过corePoolSize.
3. 通过设置corePoolSize和maxPoolSize为相同的值，就可以创建固定大小的线程池。
4. 通过设置maxPoolSize为很高的值，就可以允许线程池创建任意多的线程。

![](F:\笔记\java_Study\Multithreading\asstes\线程池总结.png)