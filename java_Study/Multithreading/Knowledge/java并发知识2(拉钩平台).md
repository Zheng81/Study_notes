# 如何停止线程?为什么volatile标记位的停止方法是错误的?

> 通常情况下，我们是不会去手动停止一个线程的，而是等线程自己运行到结束，然后让他自然的停止，但也存在需要让我们去手动停止线程的时候(例如:用户突然关闭程序，或程序运行时出错重启)如果要写一个健壮性很好的，能应付各种场景的程序，那么正确停止线程就发挥了他的作用了。

对于Java而言，最正确的停止线程的方法是使用interrupt(只起到**通知**被停止线程的作用)，而对于被停止的线程来说，它拥有完全的自主权，它可以选择接受interrupt的通知，立即停止，也可以选择一段时间后停止，当然也可不停止。

1. **为什么java不提供强制停止线程的能力呢?**

   事实上，java希望程序间能够相互通知，相互协作地管理线程，因为如果不了解对方正在做的工作，贸然去强制停止线程就可能造成一些安全问题，为了避免造成问题就需要给对方一定的时间去整理收尾工作。(例如:线程正在写入一个文件，这时收到了终止信号，它就需要根据自身业务判断是选择立即停止还是将整个文件写入成功后停止，而如果选择立即停止就可以造成数据不完整，不管是中断命令发起者还是接受者都不希望数据出现问题。)

2. **如何使用interrupt停止线程**

   ```java
   while (!Thread.currentThread().islnterrupted() && more work to do) {
       do more work
   }
   //Thread.currentThread().islnterrupted() 用于判断线程是否被中断
   //而&&后面检查是否还有工作要做
   ```

   interrupt的实现停止线程的逻辑是这样的:一旦调用了某个线程的intrrupt()之后，这个线程的中断标记位就会被设置为true。(**每个线程都有这样的标记位**),当线程执行时，应该定期检查这个标记位，如果标记位被设置成true，就说明有程序向终止该线程。

   例如：具体的例子

   ![](F:\笔记\java_Study\Multithreading\asstes\停止线程.png)

   在StopThread类的run()方法中，首先判断线程是否被中断，然后判断count值是否小于1000。这个线程的工作内容很简单，就是打印0~999的数字，每打印一个数字coun值加1，可以看到，线程会在每次循环开始之前，检查是否被中断了。接下来在main函数中会启动该线程，然后休眠5毫秒后立刻中断线程，该线程会检测到中断信号，于是在还没打印完1000个数的时候就会停下来，这种就属于通过 interrupt 正确停止线程的情况。

   #### 考虑在sleep期间能否收到中断信号

   ![](F:\笔记\java_Study\Multithreading\asstes\停止线程2.png)

   主线程休眠5毫秒后，通知子线程中断，此时子线程仍在执行sleep语句，处于休眠中。那么就需要考虑一点，在休眠中的线程是否能够感受到中断通知呢？是否需要等到休眠结束后才能中断线程呢？如果是这样，就会带来严重的问题，因为响应中断太不及时了。正因为如此，Java 设计者在设计之初就考虑到了这一点。

   如果sleep、wait等可以让线程进入阻塞的方法使线程休眠了，而处于休眠中的线程被中断，那么线程是可以感受到中断信号的，并且会抛出一个InterruptedException异常，同时清除中断信号，将中断标记位设置成 false。这样一来就不用担心长时间休眠中线程感受不到中断了，因为即便线程还在休眠，仍然能够响应中断通知，并抛出异常。

   #### 两种最佳处理在sleep期间不能收到中断信息的方式：方法签名抛异常或run()强制try/catch

   ![](F:\笔记\java_Study\Multithreading\asstes\sleep休眠中进行中断.png)

   ![](F:\笔记\java_Study\Multithreading\asstes\sleep休眠时接受中断.png)

   ![](F:\笔记\java_Study\Multithreading\asstes\volatile.png)

   ![](F:\笔记\java_Study\Multithreading\asstes\volatile2.png)

   ![](F:\笔记\java_Study\Multithreading\asstes\volatile3.png)

   

3. 