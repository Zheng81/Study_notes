# 多态

对于多态

Father temp = new Child();

如果调用重写的成员变量：

编译看左边(父类)，运行看左边(父类)

成员方法：

编译看左边(父类)，运行看右边(子类)。动态绑定

静态方法:

编译 看左边(父类)

以上是一篇博客中所写内容

------

## 多态，其实就是围绕着 Father temp = new Child()的意思

> 为什么这样说呢?

是因为多态的作用:多态不仅能改善代码的组织结构和可读性，还能够创建可扩展的程序。用于消除类型之间的耦合关系。(将实现和接口分离开来)

例如:Father temp = new Child(),这个例子中用一个向上转型为一个父类引用，但这个引用由于子类中重写了父类的东西(且不是用static或者final,private修饰的重写方法)，那么这个对象在调用重写方法时，他所实现的是子类中覆盖了父类的内容。![](F:\笔记\java_Study\Tinking in java\assets\多态例子.png)

![](F:\笔记\java_Study\Tinking in java\assets\多态例子运行结果.png)

## 方法调用绑定

> 什么是绑定?

将一个方法调用同一个方法主体关联起来

### 1.前期绑定

**定义：**在程序执行前进行绑定。(这就绑定就像是C语言中定义define一样,在程序编译时就弄好的内容，实际上是C也只有这种前期绑定)

### 2.后期绑定

**定义：**在运行时根据对象的类型进行绑定。而这种绑定也叫动态绑定或者运行时绑定。

如果一个语言要实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法，也就是编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。



**（注）在java中，除了static方法和final方法(private方法属于final方法)之外，其他所有的方法都是后期绑定。**这就意味着通常情况下，我们不必判定是否应该进行后期绑定——它会自动发生。

故方法声明为final,这样就可以防止别人去覆盖该方法，且能有效地"关闭"动态绑定，或者说，告诉编译器不需要对其进行动态绑定。

### 对于多态缺点是:

1. 无法覆盖父类的私有方法

2. 域和与静态方法的调用

   在多态，只有普通的方法调用是可以是多态的，但如果是直接去访问某个域的话，这个访问就将在编译期进行解析了。

   其实理解起来，也就是方法和成员变量之间在多态的形式下，多态的动态绑定针对的是普通的方法，而不动态绑定成员变量。(但在项目开发中，经常使用的是将成员变量都设置成了private，然后通过调用getxxx和setxxx方法来调用和设置该域的值。)

3. 如果某个方法是静态的，那么他的行为就不具有多态性。(静态方法是与类，并非与单个对象相关联)

   如果一个父类中的方法是一个静态方法(即用static修饰)的话,那么他在子类进行重写，而向上转型时，调用该方法时，调用的不是子类重写的方法，而是父类的方法。

4. 对于构造器(constructor)它也不具有多态性(因为他们实际上也是static方法，只不过该static声明是隐形的)

### 构造器的调用顺序

1. 调用基类构造器。(这个步骤会不断地反复递归下去，首先是构造这种层次结构的根，然后是下一层子类，等等，直到最底层的子类。)
2. 按声明顺序调用成员的初始化方法。
3. 调用导出类构造器的主体。

![](F:\笔记\java_Study\Tinking in java\assets\构造器的调用顺序.png)

![构造器的调用顺序2](F:\笔记\java_Study\Tinking in java\assets\构造器的调用顺序2.png)

![构造器的调用顺序3](F:\笔记\java_Study\Tinking in java\assets\构造器的调用顺序3.png)

### 构造器的调用顺序(未完全版)

1. 调用基类构造器。(这个步骤会不断地反复递归下去，首先是构造这种层次结构的根，然后是下一层导出类，等等，直到最底层的导出类。)
2. 按声明顺序调用成员的初始化方法。
3. 调用导出类构造器的主体。

> 为什么说上述的调用顺序是未完成版？

这个，可以考虑一种问题，如果一个构造器的内部在调用正在构造的对象的某个动态绑定，那么会发生什么情况？

<font color=#FF0000>在一般的方法内部，动态绑定的调用是在运行时才决定的，因为对象无法知道它是属于方法所在的类，还是属于那个类的子类。如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖后的定义。然而，这个调用效果是可能相当难于预料。因为被覆盖的方法在对象被完全构造之前就会被调用。这可能会造成一些难于发现的隐藏错误。从概念上讲，**构造器的工作实际上就是创建对象**(这并非是一件平常的工作)。在任何构造器内部，整个对象可能只是部分形成——我们只知道基类对象已经进行初始化。如果构造器只是在构建对象过程中的一个步骤，并且该对象所属的类是从这个构造器所属的类导出的，那么导出部分在当前构造器正在被调用的时刻仍旧是没有被初始化的。然而，一个动态绑定的方法调用却会向外深入到继承层次内部，它可以调用导出类里的方法。如果我们是在构造器内部这样做，那么就可能会调用某个方法，而这个方法所操纵的成员可能还未进行初始化——这肯定会招致灾难</font>（这都是课本原话）

![](F:\笔记\java_Study\Tinking in java\assets\构造器内部的多态方法的行为.jpg)

在这个程序中，注意的是输出的radius值。Glyph.draw()方法设计为将要被覆盖，这种覆盖是在RoundGlyph中发生的。但是Glyph构造器会调用这个方法，结果导致了到RoundGlyph.draw()的调用，这看似我们的目的，但是radius的输出结果，我们可以发现当Glphy的构造器调用draw()方法时，radius不是默认初始化1，而是0.这可能导致在屏幕上只画了个点，或者根本什么东西都没有；我们只能干瞪眼，并试图去找出程序无法运转的原因所在。

### 而解开这个谜题的关键就是完整的初始化过程:

1. 在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的0。
2. 如前所述那样调用基类构造器。此时，调用被覆盖后的draw()方法(要在调用RoundGlyph构造器之前调用)，由于步骤1的缘故，我们此时会发现radius的值为0。
3. 按照声明的顺序调用成员的初始化方法。
4. 调用导出类的构造器主体。

**初始化中的步骤1的优点:**所有的对象至少初始化为0(或者是某些特殊数据中与"零"等价的值)，而不是仅仅留做垃圾。其中包括通过"组合"而嵌入一个类内部的对象引用，其值是null。所有如果忘记为该引用进行初始化，就会在运行时出现异常。查看输出结果时，会发现其他所有东西的值都会是零，这通常也正是发现问题的证据。

<font color = #FF0000>对于出现的这种问题。我们在编写构造器有一条有效的准则:“用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法”。</font>在构造器内唯一能够安全调用的那些方法是基类中的final方法(也适用于private方法，他们自动属于final方法)。这些方法不能被覆盖，因此也就不会出现上述令人惊讶的问题。

### 协变返回类型

javaSE5中的新特性,它表示在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型。

<img src="F:\笔记\java_Study\Tinking in java\assets\协变返回类型.jpg" style="zoom:67%;" />

### 向下转型与运行时类型识别

向下转型时，相当于精度缺失，需要我们使用强转换符(即括号) (向下转型就如同:我们无法知道一个"几何形状"它确实就是一个"圆",它可以是一个三角形、正方形或其他一些类型。)

向下转型不太安全，故在进入运行期时仍然会对其进行检查，以便保证它确实是我们希望的那种类型。如果不是，就会返回一个ClassCastException(类型转换异常)。这种在运行期间对类型进行检查的行为称为:"运行时类型识别“（RTTI））——(注意:RTTI不仅仅包括转型处理)

### 总结:

<font color = #FF0000>多态意味着"不同的形式"。在面对对象的程序设计中，我们持有从基类继承而来的相同接口，以及使用该接口的不同形式:不同版本的动态绑定。</font>（还是课本原话）

在我看来。多态其实就是在基类上进行拓展，将它来进行专业化的操作，在子类中实现各种功能，将实现和接口来进行分离，但在运用多态性的时候，应注意少用抽象类，因为它不太灵活，会增强程序的耦合度(即实现和接口的分离程度不够),建议使用interface(接口技术)。